<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Showroom 3D JSON + Drag + Box Types</title>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
  }
}
</script>

<style>
/* ===== Global ===== */
body {
  margin:0;
  overflow:hidden;
  font-family:system-ui,-apple-system,BlinkMacSystemFont;
  background:#000;
  color:#fff;
}
canvas { display:block; }

/* ===== Version ===== */
#version {
  position:fixed;
  top:14px;
  right:18px;
  font-size:14px;
  opacity:.6;
  z-index:20;
}

/* ===== Loader ===== */
#loader {
  position: fixed;
  inset: 0;
  background: #000;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}
#loaderContent { text-align:center; }
#loaderText { font-size:1.4rem; margin-bottom:20px; }
#loaderBar {
  width: 280px;
  height: 14px;
  background: rgba(255,255,255,0.2);
  border-radius: 8px;
  overflow: hidden;
}
#loaderProgress {
  height:100%;
  width:0;
  background:#fff;
}

/* ===== Burger ===== */
#burger {
  position:fixed;
  top:20px;
  left:20px;
  width:36px;
  cursor:pointer;
  z-index:15;
}
#burger span {
  display:block;
  height:4px;
  background:#fff;
  margin:6px 0;
  border-radius:2px;
}

/* ===== Menu ===== */
#sideMenu {
  position:fixed;
  inset:0 auto 0 0;
  width:300px;
  background:rgba(0,0,0,.96);
  padding:90px 30px;
  transform:translateX(-100%);
  transition:.35s;
  z-index:14;
}
#sideMenu.open { transform:translateX(0); }

.menuItem {
  display:block;
  width:100%;
  background:none;
  border:none;
  color:#fff;
  font-size:18px;
  padding:16px 0;
  text-align:left;
  cursor:pointer;
  opacity:.85;
}
.menuItem:hover { opacity:1; }

/* ===== Open Button ===== */
#openBtn {
  position:fixed;
  top:20px;
  left:50%;
  transform:translateX(-50%);
  padding:14px 42px;
  border-radius:40px;
  border:none;
  background:#fff;
  font-size:18px;
  font-weight:600;
  cursor:pointer;
  opacity:0;
  pointer-events:none;
  transition:.3s;
  z-index:15;
}
#openBtn.visible {
  opacity:1;
  pointer-events:auto;
}

/* ===== Overlay ===== */
#overlay {
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.9);
  backdrop-filter:blur(10px);
  display:none;
  z-index:20;
  justify-content:center;
  align-items:center;
  padding:20px;
}

#overlayContent {
  display:flex;
  max-width:1300px;
  width:100%;
  height:80%;
  background:rgba(20,20,20,.96);
  border-radius:26px;
  overflow:hidden;
}

#overlayText {
  width:45%;
  padding:50px;
  display:flex;
  flex-direction:column;
  justify-content:center;
  gap:24px;
}

#overlayText h2 {
  font-size:2.4rem;
  margin:0;
}
#overlayText p {
  font-size:1.1rem;
  line-height:1.6;
  color:#ccc;
}

#overlayCanvas {
  width:55%;
  display:flex;
  justify-content:center;
  align-items:center;
}

/* ===== Close ===== */
#closeBtn {
  position:absolute;
  top:24px;
  left:24px;
  padding:12px 22px;
  border-radius:30px;
  border:none;
  background:rgba(255,255,255,.15);
  color:#fff;
  font-weight:600;
  cursor:pointer;
}

/* ===== Steam ===== */
#steamBtn {
  margin-top:10px;
  padding:16px 36px;
  border:none;
  border-radius:14px;
  background:#1b2838;
  color:#fff;
  font-size:1.1rem;
  font-weight:600;
  cursor:pointer;
}

/* ===== Mobile ===== */
@media(max-width:900px){
  #overlayContent {
    flex-direction:column-reverse;
    height:90%;
  }
  #overlayText, #overlayCanvas {
    width:100%;
    height:50%;
    padding:30px;
  }
}

@media(max-width:600px){
  #sideMenu { width:90%; }
  #openBtn {
    font-size:20px;
    padding:16px 50px;
  }
  #overlayText h2 { font-size:1.9rem; }
  #overlayText p { font-size:1.05rem; }
}
</style>
</head>

<body>

<div id="version">v0.1.0 - UI Enhancement</div>

<div id="loader">
  <div id="loaderContent">
    <p id="loaderText">Chargement... 0%</p>
    <div id="loaderBar"><div id="loaderProgress"></div></div>
  </div>
</div>

<div id="burger"><span></span><span></span><span></span></div>
<div id="sideMenu"></div>
<button id="openBtn">Ouvrir</button>

<div id="overlay">
  <button id="closeBtn">Quitter</button>
  <div id="overlayContent">
    <div id="overlayText">
      <h2 id="detailTitle"></h2>
      <p id="detailDesc"></p>
    </div>
    <div id="overlayCanvas"></div>
  </div>
</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { GLTFLoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";
import { Reflector } from "https://unpkg.com/three@0.160.0/examples/jsm/objects/Reflector.js";

/* ===== Loader variables ===== */
let resourcesToLoad = 0;
let resourcesLoaded = 0;

function updateLoader() {
  const progress = resourcesToLoad ? Math.floor((resourcesLoaded / resourcesToLoad) * 100) : 0;
  document.getElementById("loaderProgress").style.width = progress + "%";
  document.getElementById("loaderText").textContent = `Chargement... ${progress}%`;
  if(resourcesLoaded >= resourcesToLoad) {
    document.getElementById("loader").style.display = "none";
  }
}

/* ===== Globals ===== */
let DATA={}, currentCategory=null;
let instances=[], active=null;
let isDragging=false, dragStarted=false, prevMouse={x:0,y:0};
const dragThreshold=2;
let overlayActive = false;
let hovered = null;

/* ===== Camera original position ===== */
let cameraInitialPosition = new THREE.Vector3();
let cameraInitialTarget = new THREE.Vector3();

/* ===== Cache ===== */
const boxCache = {};
const textureCache = {};

/* ===== Elements HTML ===== */
const burger = document.getElementById("burger");
const sideMenu = document.getElementById("sideMenu");
const openBtn = document.getElementById("openBtn");
const overlay = document.getElementById("overlay");
const closeBtn = document.getElementById("closeBtn");
const overlayCanvas = document.getElementById("overlayCanvas");
const detailTitle = document.getElementById("detailTitle");
const detailDesc = document.getElementById("detailDesc");

/* ===== Burger menu ===== */
burger.onclick = () => sideMenu.classList.toggle("open");

/* ===== Three.js main scene ===== */
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0,0.4,0.8);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableRotate = window.innerWidth <= 900 ? true : false;
controls.enableZoom = true;
controls.enablePan = false;
controls.rotateSpeed = 0.5;
controls.zoomSpeed = 0.8;

scene.add(new THREE.AmbientLight(0xffffff,1));
const dirLight = new THREE.DirectionalLight(0xffffff, 1.8);
dirLight.position.set(5,10,7);
scene.add(dirLight);

const reflector = new Reflector(new THREE.PlaneGeometry(10,10), {color:0x555555});
reflector.rotation.x = -Math.PI/2;
scene.add(reflector);

const gltfLoader = new GLTFLoader();
const textureLoader = new THREE.TextureLoader();

/* ===== Load JSON ===== */
fetch("./data.json")
  .then(r => r.json())
  .then(json => {
    DATA = json;
    buildMenu();
    loadCategory(Object.keys(DATA)[0]);
  });

/* ===== Build menu ===== */
function buildMenu() {
  sideMenu.innerHTML = "";
  let totalGames = 0;

  Object.keys(DATA).forEach(cat => {
    const items = DATA[cat];
    totalGames += items.length;

    const b = document.createElement("button");
    b.className = "menuItem";
    b.textContent = `${cat} (${items.length})`;
    b.onclick = () => loadCategory(cat);
    sideMenu.appendChild(b);
  });

  const totalEl = document.createElement("div");
  totalEl.style.position = "absolute";
  totalEl.style.bottom = "30px";
  totalEl.style.left = "30px";
  totalEl.style.color = "#fff";
  totalEl.style.fontSize = "16px";
  totalEl.textContent = `Total jeux : ${totalGames}`;
  sideMenu.appendChild(totalEl);
}

/* ===== Camera helper ===== */
function animateCameraTo(inst, duration = 0.5) {
  const box = new THREE.Box3().setFromObject(inst.mesh);
  const size = box.getSize(new THREE.Vector3());
  const targetCenter = new THREE.Vector3(inst.targetX, box.getCenter(new THREE.Vector3()).y, box.getCenter(new THREE.Vector3()).z);
  const targetPos = new THREE.Vector3(
    targetCenter.x,
    targetCenter.y + size.y / 2,
    targetCenter.z + Math.max(size.x, size.y, size.z) / (2 * Math.tan(camera.fov * Math.PI / 360)) * 1.5
  );

  const startPos = camera.position.clone();
  const startTarget = controls.target.clone();
  let t = 0;

  function updateCamera(dt){
    t += dt / duration;
    if(t >= 1) t = 1;
    camera.position.lerpVectors(startPos, targetPos, t);
    controls.target.lerpVectors(startTarget, targetCenter, t);
    controls.update();
    if(t < 1) requestAnimationFrame(updateCamera);
  }
  requestAnimationFrame(updateCamera);
}

function centerCameraOn(inst) {
  const box = new THREE.Box3().setFromObject(inst.mesh);
  const size = box.getSize(new THREE.Vector3());
  const center = new THREE.Vector3(inst.targetX, box.getCenter(new THREE.Vector3()).y, box.getCenter(new THREE.Vector3()).z);
  const maxDim = Math.max(size.x, size.y, size.z);
  const fov = camera.fov * (Math.PI / 180);
  const distance = maxDim / (2 * Math.tan(fov / 2)) * 1.5;
  camera.position.set(center.x, center.y + size.y / 2, center.z + distance);
  controls.target.copy(center);
  controls.update();
}

/* ===== Clear instances ===== */
function clearInstances() {
  instances.forEach(i => scene.remove(i.mesh));
  instances = [];
  active = null;
  openBtn.classList.remove("visible");
}

/* ===== Helper functions ===== */
function getBoxModel(boxType, callback) {
  if(boxCache[boxType]){
    callback(boxCache[boxType].clone());
    resourcesLoaded++;
    updateLoader();
  } else {
    resourcesToLoad++;
    let path = boxType === "DVD" ? "./dvdps2wii_case.glb" : "./cdps1.glb";
    gltfLoader.load(path, gltf => {
      boxCache[boxType] = gltf.scene;
      callback(gltf.scene.clone());
      resourcesLoaded++;
      updateLoader();
    });
  }
}

function getTexture(path) {
  if(textureCache[path]) {
    resourcesLoaded++;
    updateLoader();
    return textureCache[path];
  }
  resourcesToLoad++;
  const tex = textureLoader.load(path, () => {
    resourcesLoaded++;
    updateLoader();
  });
  tex.flipY = false;
  tex.colorSpace = THREE.SRGBColorSpace;
  textureCache[path] = tex;
  return tex;
}

/* ===== Load category ===== */
function loadCategory(cat) {
  sideMenu.classList.remove("open");
  currentCategory = cat;
  clearInstances();

  const items = DATA[cat];
  let loadedCount = 0;

  items.forEach((item, i) => {
    getBoxModel(item.box, original => {
      let box = new THREE.Box3().setFromObject(original);
      let size = box.getSize(new THREE.Vector3());
      const targetSize = 0.2;
      const maxDim = Math.max(size.x, size.y, size.z);
      const scale = targetSize / maxDim;
      original.scale.setScalar(scale);

      box = new THREE.Box3().setFromObject(original);
      size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      original.position.sub(center);
      original.position.y += size.y / 2;

      const mesh = original.clone(true);
      const tex = getTexture(item.texturePath);
      mesh.traverse(c => {
        if(c.isMesh){
          c.material = c.material.clone();
          if(c.material.map !== undefined) c.material.map = tex;
        }
      });

      const baseX = (i - (items.length - 1)/2) * size.z * 1.2;
      mesh.position.x = baseX;
      mesh.position.z = 0;
      mesh.rotation.y = Math.PI / 2;

      instances.push({
        mesh,
        baseX,
        targetX: baseX,
        baseZ: 0,
        targetZ: 0,
        initialRotY: mesh.rotation.y,
        data: item,
        isToggled: false,
        initialPosition: mesh.position.clone()
      });

      scene.add(mesh);
      loadedCount++;
      if(loadedCount === items.length) {
        zoomToFitAll();
        cameraInitialPosition.copy(camera.position);
        cameraInitialTarget.copy(controls.target);
      }
    });
  });
}

/* ===== Zoom automatique ===== */
function zoomToFitAll() {
  if(instances.length === 0) return;
  const box = new THREE.Box3();
  instances.forEach(i => box.expandByObject(i.mesh));
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());
  const maxDim = Math.max(size.x, size.y, size.z);
  const fov = camera.fov * (Math.PI / 180);
  let distance = maxDim / (2 * Math.tan(fov / 2)) * 1.30;
  if(innerWidth < 600) distance *= 1.1;
  camera.position.set(center.x, center.y + size.y / 2, center.z + distance);
  camera.lookAt(center);
  controls.target.copy(center);
  controls.update();
}

/* ===== Interaction & Drag ===== */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

/* === Mouse Events === */
window.addEventListener("click", e => {
  if(overlayActive) return;
  if(dragStarted){ dragStarted=false; return; }

  mouse.x = (e.clientX / innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  const allIntersections = [];
  instances.forEach(inst=>{
    const hits = raycaster.intersectObject(inst.mesh, true);
    hits.forEach(hit => allIntersections.push({inst, distance: hit.distance}));
  });
  if(allIntersections.length === 0) return;
  allIntersections.sort((a,b) => a.distance - b.distance);
  const closest = allIntersections[0].inst;

  if(active && active!==closest) reset(active);
  closest.isToggled ? reset(closest) : toggle(closest);
  active = closest.isToggled ? closest : null;
});

window.addEventListener("mousedown", e => {
  if(overlayActive) return;
  if(!active) return;
  isDragging = true;
  dragStarted = false;
  prevMouse = {x:e.clientX, y:e.clientY};
});

window.addEventListener("mousemove", e => {
  if(overlayActive) return;

  mouse.x = (e.clientX / innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  if(isDragging && active){
    const dx = e.clientX - prevMouse.x;
    const dy = e.clientY - prevMouse.y;
    if(Math.abs(dx)+Math.abs(dy) > dragThreshold) dragStarted = true;
    active.mesh.rotation.y += dx*0.01;
    active.mesh.rotation.x += dy*0.01;
    prevMouse = {x:e.clientX, y:e.clientY};
  }

  // Hover
  const allHits = [];
  instances.forEach(inst => {
    if(inst.isToggled) return;
    const hits = raycaster.intersectObject(inst.mesh, true);
    if(hits.length) allHits.push({inst, distance: hits[0].distance});
  });

  if(allHits.length > 0){
    allHits.sort((a,b) => a.distance - b.distance);
    const closest = allHits[0].inst;
    if(hovered !== closest){
      if(hovered) setHover(hovered,false);
      setHover(closest,true);
      hovered = closest;
    }
  } else {
    if(hovered){
      setHover(hovered,false);
      hovered = null;
    }
  }
});

window.addEventListener("mouseup", e => {
  if(overlayActive) return;
  isDragging = false;
});

/* === Touch Events for Mobile === */
window.addEventListener("touchstart", e => {
  if(overlayActive) return;
  if(!active) return;
  isDragging = true;
  dragStarted = false;
  const t = e.touches[0];
  prevMouse = {x: t.clientX, y: t.clientY};
});

window.addEventListener("touchmove", e => {
  if(overlayActive) return;
  if(!isDragging || !active) return;
  const t = e.touches[0];
  const dx = t.clientX - prevMouse.x;
  const dy = t.clientY - prevMouse.y;
  if(Math.abs(dx)+Math.abs(dy) > dragThreshold) dragStarted = true;
  active.mesh.rotation.y += dx*0.01;
  active.mesh.rotation.x += dy*0.01;
  prevMouse = {x: t.clientX, y: t.clientY};
});

window.addEventListener("touchend", e => {
  if(overlayActive) return;
  isDragging = false;
});

/* ===== Appearance & hover ===== */
function updateAppearance(inst){
  inst.mesh.traverse(c=>{
    if(!c.isMesh) return;
    if(!c.userData.originalMaterial) c.userData.originalMaterial = c.material;
    let mat = c.userData.originalMaterial.clone();
    if(inst.isDimmed && !inst.isHovered){
      mat.color.multiplyScalar(0.1);
      mat.emissive.multiplyScalar(0.1);
    } else if(inst.isHovered){
      mat.color.copy(c.userData.originalMaterial.color);
      mat.color.offsetHSL(0,0,0.3);
    }
    c.material.dispose();
    c.material = mat;
  });
}

function setHover(inst,on){
  inst.isHovered = on;
  updateAppearance(inst);
}

function setGray(inst, gray=true){
  inst.isDimmed = gray;
  updateAppearance(inst);
}

/* ===== Toggle / Reset avec recul horizontal + profondeur ===== */
function toggle(inst){
  inst.isToggled = true;
  inst.mesh.rotation.set(0, inst.initialRotY - Math.PI/2, 0);

  const w = new THREE.Box3().setFromObject(inst.mesh).getSize(new THREE.Vector3()).x;
  const spacing = w * 0.6;
  const zOffset = 0.15;

  instances.forEach(o => {
    if(o === inst){
      o.targetX = o.baseX;
      o.targetZ = 0;
      setGray(o,false);
    } else {
      o.targetX = o.baseX + (o.baseX < inst.baseX ? -1 : 1) * spacing;
      o.targetZ = -zOffset;
      setGray(o,true);
    }
  });

  active = inst;
  openBtn.classList.add("visible");
  centerCameraOn(inst);
  animateCameraTo(inst);
}

function reset(inst){
  inst.isToggled = false;
  inst.mesh.rotation.set(0, inst.initialRotY, 0);

  instances.forEach(o => {
    o.targetX = o.baseX;
    o.targetZ = 0;
    o.mesh.position.copy(o.initialPosition);
    setGray(o,false);
  });

  active = null;
  openBtn.classList.remove("visible");

  camera.position.copy(cameraInitialPosition);
  controls.target.copy(cameraInitialTarget);
  controls.update();
}

/* ===== Animate main ===== */
function animate(){
  requestAnimationFrame(animate);
  instances.forEach(i => {
    i.mesh.position.x += (i.targetX - i.mesh.position.x) * 0.1;
    i.mesh.position.z += (i.targetZ - i.mesh.position.z) * 0.1;
  });
  renderer.render(scene,camera);
}
animate();

/* ===== Overlay ===== */
let oRenderer,oScene,oCamera,oModel,oAnim=false;

openBtn.onclick = () => {
  if(!active) return;
  overlayActive = true;
  detailTitle.textContent = active.data.title;
  detailDesc.textContent = active.data.description;
  overlay.style.display = "flex";

  let existingBtn = document.getElementById("steamBtn");
  if(existingBtn) existingBtn.remove();
  if(currentCategory === "PC" && active.data.steam_id){
    const steamBtn = document.createElement("button");
    steamBtn.id = "steamBtn";
    steamBtn.textContent = "Play on Steam";
    document.getElementById("overlayText").appendChild(steamBtn);
    steamBtn.onclick = () => window.location.href = `steam://run/${active.data.steam_id}`;
  }

  oScene = new THREE.Scene();
  oCamera = new THREE.PerspectiveCamera(45, overlayCanvas.clientWidth/overlayCanvas.clientHeight, 0.1, 10);
  oCamera.position.set(0,0,0.7);

  oRenderer = new THREE.WebGLRenderer({alpha:true,antialias:true});
  oRenderer.setSize(overlayCanvas.clientWidth, overlayCanvas.clientHeight);
  overlayCanvas.innerHTML="";
  overlayCanvas.appendChild(oRenderer.domElement);

  oScene.add(new THREE.AmbientLight(0xffffff,1.2));
  const l = new THREE.DirectionalLight(0xffffff,1.5);
  l.position.set(3,5,4);
  oScene.add(l);

  oModel = active.mesh.clone(true);
  oModel.rotation.set(0,0,0);
  const box = new THREE.Box3().setFromObject(oModel);
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());
  oModel.position.sub(center);
  const maxDim = Math.max(size.x, size.y, size.z);
  const fov = oCamera.fov * (Math.PI / 180);
  const distance = maxDim / (2 * Math.tan(fov / 2)) * 1.40;
  oCamera.position.set(0,0,distance);
  oScene.add(oModel);

  oAnim = true;
  loopOverlay();
};

function loopOverlay(){
  if(!oAnim) return;
  requestAnimationFrame(loopOverlay);
  if(oModel) oModel.rotation.y += 0.005;
  if(oRenderer && oCamera && oScene) oRenderer.render(oScene,oCamera);
}

closeBtn.onclick = () => {
  overlayActive = false;
  oAnim = false;
  overlay.style.display = "none";
  overlayCanvas.innerHTML="";
};

/* ===== Resize ===== */
onresize = () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);

  if(oCamera && oRenderer && overlayCanvas){
    oCamera.aspect = overlayCanvas.clientWidth/overlayCanvas.clientHeight;
    oCamera.updateProjectionMatrix();
    oRenderer.setSize(overlayCanvas.clientWidth, overlayCanvas.clientHeight);
  }

  zoomToFitAll();
};

</script>

</body>
</html>
